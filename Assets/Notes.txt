1- Var, Object ve Dynamic: her türlü değişken türünü tutmanı sağlar
var = hangi değişkeni atarsak o değişkeni alır
object = var gibi istediğin değişkeni tutabilirsin fakat farklı bir değişkene eşitleyince dönüştürme yapman gerekir intNumber.ToString(); gibi
dynamic
*NOT:* dynamic runtime içinde hata verir ama object direkt solution'da hata verir. mesela dönüştürme yapmadan dynamic kullanılabilir ama object kullanılamaz. 

2- CODE

3- Lists:
listName.Remove(8) = listedeki 8 sayısını direkt siler fakat RemoveAt kullanırsan indekstekini siler
BinarySearch() = yazdığın değişkenin indexi kaçsa sana onu verir

4- Params:
parametrede verilecek değerin ne kadar fazla olduğunu bilmiyorsan bu kullanılır.
çok boyutlu diziler kullanılamaz
eğer paramdan farklı yine paramter ekleyeceksen ilk o gelir params en sona eklenir çünkü paramın nerede biteceği belli değildir sonu yok.

5- Const: sabit değer demektir.
const float = 3.14f; gibi kullanılır. Bir defa set edildiği için daha değiştirilemez.

6- Class: Aynı kod bütünlüğünün yazıldığı alandır

7- Access Modifiers (erişim belirleyiciler):
public: her classtan ulaşılabilir
private: sadece o classtan erişilebilir
internal: aynı assembly yani projedeki her yerden ulaşılabilir. Başka assembly'lerden erişilemez.

8- Constructor (Kurucu): Class'lar ile kullanılır
İçinde oluşturulduğu anda ilk çalışan metoddur.

9- Overload: aşırı yükleme yani farklı parametre şekilleriyle kullanılabilir.
aynı şekilde sınıfları constructorlar ile overload işlemi yapabilirsin.

10- Enum: 
bunların eşitliğini kontrol ederken Equals kullanmak daha iyi == yerine.
sen atama yapmasan bile listelerdeki gibi hepsinin index değeri vardır.
Enum. diyerek çeşitli işlemler yaptırabilirsin.

11- Encapsullation (kapsülleme): Dışarıya bilgi vermeden veriye çekme ve atama yapılır.
Field: sınıf veya yapı içinde tanımlanan değişkenlerdir.
*propfull ve prop diye kısayolları vardır oluşturmak için.
*oluşturulan property'de harfler fonksiyon yapısındaki gibi olmalıdır.

12- Inheritance (kalıtım-miras): Farklı bir class'tan başka bir class üretmektir. iç içe class denilebilir.
Eğer farklı 2 class ortak bilgilere sahip olma durumu varsa bu kullanılır örneğin insan ve zombi yürür bu yüzden humonoid ana class oluşturulabilir.
Derived Class: türettiğin insan zombi sınıfı olur
Base Class: Humonoid class'ı.
*Her zaman ilk base class'tan itibaren kod okunmaya başlar. Ve C# çoklu kalıtım desteklemek yani , koyup bir base class daha ekleymezsin.

13- Base Anahtar Kelimesi:
* Örneğin A base classın var ve b devired kalıtım yapılmış class'ın var ikisinde de aynı fonksiyon adı var fakat sen b classın'Da bir fonksiyon çağırırken hangisini seçecek
-kafası karışıyor bu yüzden base. yaparsan ana classı seçer eğer düz yazarsan olduğun class'takini çağırır.
* constructor ile kullanımında public A(int x):base(x){} gibi kullanılır öncelik vermek için veya hangisini çalıştıracağını anlatmak için
bunu kullanmanın sebebi base class boş construct yapısını oynatır eğer yanını bunu yazarsan aynı türden parametreleri oynatır.

14- Protected - protected internal:
Protected: Kendisinden türetilmiş olan class'larda kullanılabilir sadece.
Protected internal: aynı projelerde olmasa bile türetilmiş class'lardan erişilebilir.

15- This: bulunduğu class'ı işaret eder.
* public A(int x, int y, int z):this(x) verilirse eğer parametresi x olan constructor'da çalışacaktır. çünkü ilk çağırdığımızda 3 değer veriyoruz fakat x başta eşitleniyor o yüzden bu kullanılır.

16- Readonly: sadece okunabilir demek ve daha sonra değiştirelemez sadece okunabilir
Direkt çağıralamaz ilk başta sınıfın oluşturulması gerekiyor
mesela const'ta değeri direkt vermen gerekir ama readonly'de istersen consrtuctor'da verebilirsin.

17- Değer ve Referans Tipleri: stack / heap
değer tipleri: stacki işaret eder. int float double uint struct etc...
referans tipleri: stack'den heapi gösterir. class,object,array,interface,delegate,string
* stack değerlerini farklı classtan çağırıp değişiklik yaparak yazdırırsan değişimi göremezsin fakat heap ile yaparsan görebilirsin çünkü değişkeni üstüne yazılıp tutulur.

18- Ref and Out: bir değişken kopyalanarak gelip değerini değiştirip göremiyorsan o zaman kullanılır
ref: direkt objeye vermek istediğin değeri yazacağın zaman verirsin bunu stack veri yani değer tipleriyle kullanırsın genelde
out: bir fonksiyondan örneğin bir değeri return etmeden dışarı çıkarmada kullanılır
* prop'lar ile birlikte kullanılamaz/ paramtre ve çağıralacak yerde hangisini kullanıysan 2 yerdede başına onu yazman gerekir.

19- Static and Non-Static: 
Static: bunu yaptığın zaman nesneden bağımsız olur ve her yerden çağrılabilir. Nesnenin içinden çağıramazsın
*Nesneden bağımsız olduğu için hangi değeri atarsan her yerde o geçerli olur.
*Constructor ile işlem yaptırırsan o kayıtlı kalır
*static class'larda kalıtım olmaz ve static class içindeki her şey static olmalıdır. Constructor'da public vs yazamazsın static olur sadece

20- New anahtarı: 
*Bu derived class'ın ve base classta aynı değişken veya obje varsa derived class'ta konulur ki bizim yaptığımız belli etmek için. Çünkü override etmemiş oluyoruz yeni bir fonksiyon gibi.

21- Garbage Collection and Destructor (yıkıcı metod)
GC: stack'taki değerler (örneğin A test = new A(); ) heap'e işaret ettiği için yani new A(); olmadığı için burayı etkilemez fakat new A(); yani işaret edilmiyorsa bir şeye eşitlenmemişse (gereksizleri) onu siler. GC.Collect(); ile siler.
*Eğer heap çok doluysa OutOfMemoryException (hafıza dolu) hatası alırsın ve kötü bir kod demektir bu.
*GC'da generation vardır yani stack'tan işaret verilmemişse (bir değere eşitlenmemişse) onları siler ama hala bağı olan varsa onlar jenerasyon atlar ve 0 -1 -2 diye gider.
Destructor: Nesne silinmeden önce çalışır ve sonra nesne silinir. ~MyClass(){ //Code } şeklinde kullanılır.





















































